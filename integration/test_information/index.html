<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>テスト情報一覧</title>
    <link rel="stylesheet" href="../styles.css" />
  </head>
  <body class="dashboard-body mode-fullscreen allow-scroll">
    <!-- ハンバーガーメニュー -->
    <button id="nav-toggle" class="site-nav-toggle" aria-label="メニューを開く" aria-expanded="false">
      <span class="hamburger" aria-hidden="true"></span>
    </button>

    <nav id="nav-drawer" class="nav-drawer" aria-hidden="true" aria-label="サイトナビゲーション">
      <h2>ナビゲーション</h2>
      <ul>
        <li><a href="../index.html">統合トップ</a></li>
        <li><a href="../catalog/index.html">カタログ</a></li>
        <li><a href="../ats/index.html">ATS</a></li>
        <li><a href="../achievements/index.html">実績</a></li>
        <li><a href="../nonconformity_information/index.html">不適合情報</a></li>
        <li><a href="../physical_properties/index.html">物性</a></li>
      </ul>
    </nav>
    <div id="nav-overlay" class="nav-overlay" tabindex="-1" aria-hidden="true"></div>
    <main class="shell shell--fullscreen dashboard-shell">
      <header class="masthead masthead--compact">
        <h1>テスト情報一覧</h1>
      </header>
      <main class="dashboard-main">
        <!-- フィルタを横幅いっぱいに表示（physical_properties と同等） -->
        <form class="dashboard-filters" aria-label="期間指定フォーム">
          <div class="filter-group">
            <label for="date-from" class="filter-label">開始日</label>
            <input type="date" id="date-from" class="filter-input" value="2024-01-01" />
          </div>
          <div class="filter-group">
            <label for="date-to" class="filter-label">終了日</label>
            <input type="date" id="date-to" class="filter-input" value="2025-12-31" />
          </div>
          <button type="button" class="filter-button">検索</button>
        </form>
        <section class="dashboard-section" aria-live="polite">
          <header class="dashboard-section__header">
            <h2 class="dashboard-section__title">粉体物性情報</h2>
            <button type="button" class="control-button" id="export-button">
              <svg width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
                <path
                  fill="currentColor"
                  d="M12 3a1 1 0 0 1 1 1v8.59l2.3-2.3a1 1 0 1 1 1.4 1.42l-4 4a1 1 0 0 1-1.4 0l-4-4a1 1 0 1 1 1.4-1.42L11 12.59V4a1 1 0 0 1 1-1zM5 19a1 1 0 0 1 0-2h14a1 1 0 1 1 0 2H5z"
                ></path>
              </svg>
              エクスポート
            </button>
          </header>
          <div class="table-frame">
            <div class="data-table-wrapper">
              <table class="data-table" id="information-table">
                <thead></thead>
                <tbody></tbody>
              </table>
            </div>
          </div>
          <!-- 表示期間は不要のため削除 -->
        </section>
      </main>
    </main>
    <script>
      const csvPath = "./data/test_information.csv";
      let cachedRows = null;
      let cachedHeader = null;
      let cachedFilteredRows = [];

      // CSVの読み込みと整形を統括
      async function ensureCsvRows() {
        if (cachedRows) {
          return cachedRows;
        }
        const response = await fetch(csvPath);
        if (!response.ok) {
          throw new Error("CSVの取得に失敗しました");
        }
        const text = await response.text();
        cachedRows = parseCsv(text);
        return cachedRows;
      }

      function parseCsv(text) {
        return text
          .trim()
          .split(/\r?\n/)
          .filter((line) => line.trim() !== "")
          .map((line) => line.split(","));
      }

      function parseDateInput(value) {
        if (!value) {
          return null;
        }
        const [year, month, day] = value.split("-").map(Number);
        if (!year || !month || !day) {
          return null;
        }
        return new Date(year, month - 1, day);
      }

      function parseRecordDate(value) {
        if (!value) {
          return null;
        }
        const [year, month, day] = value.split("-").map(Number);
        if (!year || !month || !day) {
          return null;
        }
        return new Date(year, month - 1, day);
      }

      function formatDateForDisplay(value) {
        if (!value) {
          return "";
        }
        const year = value.getFullYear();
        const month = String(value.getMonth() + 1).padStart(2, "0");
        const day = String(value.getDate()).padStart(2, "0");
        return `${year}/${month}/${day}`;
      }

      function formatRangeLabel(fromDate, toDate) {
        if (!fromDate && !toDate) {
          return "表示期間: 全期間";
        }
        if (fromDate && toDate) {
          return `表示期間: ${formatDateForDisplay(fromDate)} 〜 ${formatDateForDisplay(toDate)}`;
        }
        if (fromDate) {
          return `表示期間: ${formatDateForDisplay(fromDate)} 以降`;
        }
        return `表示期間: ${formatDateForDisplay(toDate)} 以前`;
      }

      function renderTable(rows, fromDate, toDate) {
        const table = document.getElementById("information-table");
        const tableHead = table.querySelector("thead");
        const tableBody = table.querySelector("tbody");
        tableHead.innerHTML = "";
        tableBody.innerHTML = "";

        const rangeLabel = document.getElementById("selected-range");
        const headerRange = document.getElementById("header-range");
        const rangeText = formatRangeLabel(fromDate, toDate);
        cachedHeader = null;
        cachedFilteredRows = [];

        if (rows.length === 0) {
          if (rangeLabel) {
            rangeLabel.textContent = rangeText;
          }
          if (headerRange) {
            headerRange.textContent = rangeText.replace("表示期間: ", "");
          }
          return;
        }

        const [header, ...records] = rows;
        cachedHeader = header;

        const headerRow = document.createElement("tr");
        header.forEach((label) => {
          const th = document.createElement("th");
          th.textContent = label.trim();
          headerRow.appendChild(th);
        });
        tableHead.appendChild(headerRow);

        const filtered = records.filter((row) => {
          const dateCell = row[0] ? row[0].trim() : "";
          if (!dateCell) {
            return false;
          }
          const recordDate = parseRecordDate(dateCell);
          if (!recordDate) {
            return true;
          }
          if (fromDate && recordDate < fromDate) {
            return false;
          }
          if (toDate && recordDate > toDate) {
            return false;
          }
          return true;
        });

        cachedFilteredRows = filtered;
        if (rangeLabel) {
          rangeLabel.textContent = rangeText;
        }
        if (headerRange) {
          headerRange.textContent = rangeText.replace("表示期間: ", "");
        }

        if (filtered.length === 0) {
          const emptyRow = document.createElement("tr");
          const emptyCell = document.createElement("td");
          emptyCell.colSpan = header.length;
          emptyCell.className = "data-table-empty";
          emptyCell.textContent = "指定された期間のデータはありません";
          emptyRow.appendChild(emptyCell);
          tableBody.appendChild(emptyRow);
          return;
        }

        const fragment = document.createDocumentFragment();
        filtered.forEach((row) => {
          const bodyRow = document.createElement("tr");
          row.forEach((cell) => {
            const td = document.createElement("td");
            td.textContent = cell.trim();
            bodyRow.appendChild(td);
          });
          fragment.appendChild(bodyRow);
        });
        tableBody.appendChild(fragment);
      }

      async function applyFilter() {
        try {
          const rows = await ensureCsvRows();
          const fromInput = document.getElementById("date-from");
          const toInput = document.getElementById("date-to");
          const fromDate = parseDateInput(fromInput.value);
          const toDate = parseDateInput(toInput.value);
          renderTable(rows, fromDate, toDate);
        } catch (error) {
          console.error(error);
          alert(`データの読み込みに失敗しました: ${error.message}`);
        }
      }

      function setupEventHandlers() {
        const button = document.getElementById("filter-button");
        const fromInput = document.getElementById("date-from");
        const toInput = document.getElementById("date-to");
        const exportButton = document.getElementById("export-button");
        if (button) {
          button.addEventListener("click", applyFilter);
        }
        [fromInput, toInput].forEach((input) => {
          if (!input) {
            return;
          }
          input.addEventListener("change", applyFilter);
        });
        if (exportButton) {
          exportButton.addEventListener("click", exportFilteredRows);
        }
      }

      document.addEventListener("DOMContentLoaded", async () => {
        setupEventHandlers();
        await applyFilter();
      });

      function escapeCsvCell(value) {
        const safeValue = value == null ? "" : String(value);
        return `"${safeValue.replace(/"/g, '""')}"`;
      }

      function exportFilteredRows() {
        if (!cachedHeader || cachedFilteredRows.length === 0) {
          alert("エクスポートできるデータがありません。条件を変更してください。");
          return;
        }
        const lines = [
          cachedHeader.map((cell) => escapeCsvCell((cell || "").trim())).join(","),
          ...cachedFilteredRows.map((row) => row.map((cell) => escapeCsvCell((cell || "").trim())).join(",")),
        ];
        const csvContent = lines.join("\r\n");
        const blob = new Blob([`\uFEFF${csvContent}`], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = "test_information_export.csv";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }
    </script>
    <script src="../navigation.js"></script>
  </body>
</html>
